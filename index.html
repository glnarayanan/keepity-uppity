<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Keepy Uppy</title>
    <style>
      :root {
        --bg: #f6f1e7;
        --ink: #111111;
        --line: #dedede;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        overflow: hidden;
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        cursor: pointer;
        touch-action: none;
      }

      #hud {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 24px;
        font-size: 16px;
        font-weight: 600;
      }

      #hud span {
        font-weight: 700;
      }

      #hint {
        position: fixed;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 14px;
        color: #555555;
        transition: opacity 0.2s ease;
      }

      #hint.hidden {
        opacity: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="game" aria-label="Soccer juggling game"></canvas>
    <div id="hud">
      <div>Score <span id="score">0</span></div>
      <div>Best <span id="best">0</span></div>
    </div>
    <div id="hint">Click the ball to start</div>

    <script>
      (() => {
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const bestEl = document.getElementById("best");
        const hintEl = document.getElementById("hint");

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
        const vibrate = (pattern) => {
          if (navigator.vibrate) {
            navigator.vibrate(pattern);
          }
        };

        const state = {
          mode: "idle",
          score: 0,
          best: 0,
          settleTime: 0,
        };

        const settings = {
          gravity: 1700,
          kick: 820,
          sideKick: 520,
          wallBounce: 0.985,
          groundBounce: 0.28,
          groundFriction: 0.9,
          rollFriction: 2.2,
        };

        const ball = {
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          r: 24,
          spin: 0,
        };

        let width = 0;
        let height = 0;
        let groundY = 0;
        let lastTime = performance.now();

        const highScoreKey = "keepyUppyHighScore";

        const loadHighScore = () => {
          try {
            const stored = Number.parseInt(localStorage.getItem(highScoreKey) || "0", 10);
            state.best = Number.isNaN(stored) ? 0 : stored;
          } catch (error) {
            state.best = 0;
          }
          bestEl.textContent = String(state.best);
        };

        const saveHighScore = () => {
          try {
            localStorage.setItem(highScoreKey, String(state.best));
          } catch (error) {
            // Ignore storage failures.
          }
        };

        const syncHud = () => {
          scoreEl.textContent = String(state.score);
          bestEl.textContent = String(state.best);
        };

        const resetBall = () => {
          ball.x = width * 0.5;
          ball.y = groundY - ball.r;
          ball.vx = 0;
          ball.vy = 0;
          ball.spin = 0;
        };

        const resetGame = () => {
          state.mode = "idle";
          state.score = 0;
          state.settleTime = 0;
          hintEl.classList.remove("hidden");
          resetBall();
          syncHud();
        };

        const resize = () => {
          const dpr = window.devicePixelRatio || 1;
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width * dpr;
          canvas.height = height * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ball.r = Math.max(20, Math.min(width, height) * 0.045);
          groundY = height - Math.max(40, height * 0.08);
          resetBall();
        };

        const drawPolygon = (sides, radius) => {
          ctx.beginPath();
          for (let i = 0; i < sides; i += 1) {
            const angle = (Math.PI * 2 * i) / sides - Math.PI / 2;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
          }
          ctx.closePath();
        };

        const drawShadow = () => {
          const height = clamp((groundY - (ball.y + ball.r)) / (ball.r * 3), 0, 1);
          const shadowScale = 1 - height * 0.5;
          const shadowAlpha = 0.25 * (1 - height);
          ctx.save();
          ctx.translate(ball.x, groundY + ball.r * 0.12);
          ctx.scale(1, 0.25);
          ctx.beginPath();
          ctx.arc(0, 0, ball.r * shadowScale, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha.toFixed(3)})`;
          ctx.fill();
          ctx.restore();
        };

        const drawBall = () => {
          ctx.save();
          ctx.translate(ball.x, ball.y);
          ctx.rotate(ball.spin);

          const baseGradient = ctx.createRadialGradient(
            -ball.r * 0.35,
            -ball.r * 0.35,
            ball.r * 0.2,
            0,
            0,
            ball.r * 1.2
          );
          baseGradient.addColorStop(0, "#ffffff");
          baseGradient.addColorStop(0.6, "#f0f0f0");
          baseGradient.addColorStop(1, "#d7d7d7");

          ctx.beginPath();
          ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
          ctx.fillStyle = baseGradient;
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#111111";
          ctx.stroke();

          const panelStroke = "rgba(120, 120, 120, 0.55)";
          const blackPanel = ctx.createLinearGradient(-ball.r, -ball.r, ball.r, ball.r);
          blackPanel.addColorStop(0, "#2b2b2b");
          blackPanel.addColorStop(1, "#050505");

          ctx.fillStyle = blackPanel;
          drawPolygon(5, ball.r * 0.36);
          ctx.fill();
          ctx.strokeStyle = panelStroke;
          ctx.lineWidth = 1;
          ctx.stroke();

          const ringRadius = ball.r * 0.62;
          for (let i = 0; i < 5; i += 1) {
            const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
            ctx.save();
            ctx.translate(Math.cos(angle) * ringRadius, Math.sin(angle) * ringRadius);
            ctx.rotate(angle);
            drawPolygon(5, ball.r * 0.22);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }

          ctx.strokeStyle = "rgba(140, 140, 140, 0.5)";
          ctx.lineWidth = 1;
          for (let i = 0; i < 5; i += 1) {
            const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(angle) * ball.r * 0.12, Math.sin(angle) * ball.r * 0.12);
            ctx.lineTo(Math.cos(angle) * ringRadius, Math.sin(angle) * ringRadius);
            ctx.stroke();
          }

          ctx.globalCompositeOperation = "multiply";
          const shade = ctx.createRadialGradient(
            ball.r * 0.25,
            ball.r * 0.35,
            ball.r * 0.2,
            0,
            0,
            ball.r * 1.1
          );
          shade.addColorStop(0, "rgba(0, 0, 0, 0)");
          shade.addColorStop(1, "rgba(0, 0, 0, 0.18)");
          ctx.fillStyle = shade;
          ctx.beginPath();
          ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
          ctx.fill();

          ctx.globalCompositeOperation = "screen";
          const highlight = ctx.createRadialGradient(
            -ball.r * 0.35,
            -ball.r * 0.35,
            ball.r * 0.05,
            -ball.r * 0.35,
            -ball.r * 0.35,
            ball.r * 0.45
          );
          highlight.addColorStop(0, "rgba(255, 255, 255, 0.9)");
          highlight.addColorStop(1, "rgba(255, 255, 255, 0)");
          ctx.fillStyle = highlight;
          ctx.beginPath();
          ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
          ctx.globalCompositeOperation = "source-over";
        };

        const drawGround = () => {
          ctx.save();
          ctx.strokeStyle = "#dedede";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, groundY + 1);
          ctx.lineTo(width, groundY + 1);
          ctx.stroke();
          ctx.restore();
        };

        const render = () => {
          ctx.clearRect(0, 0, width, height);
          drawGround();
          drawShadow();
          drawBall();
        };

        const applyKick = (clickX, clickY, pressure) => {
          const dx = clickX - ball.x;
          const dy = clickY - ball.y;
          const distance = Math.hypot(dx, dy);
          const radial = clamp(distance / ball.r, 0, 1);
          const press = clamp(typeof pressure === "number" ? pressure || 0.5 : 0.5, 0, 1);
          const boost = 0.75 + radial * 0.55 + press * 0.25;
          const normalizedX = clamp(dx / ball.r, -1, 1);

          ball.vx += -normalizedX * settings.sideKick * boost;
          ball.vy = -settings.kick * boost;
          state.score += 1;

          if (state.score > state.best) {
            state.best = state.score;
            saveHighScore();
          }

          syncHud();
          vibrate(8);
        };

        const handlePointer = (event) => {
          const rect = canvas.getBoundingClientRect();
          const clickX = event.clientX - rect.left;
          const clickY = event.clientY - rect.top;
          const dx = clickX - ball.x;
          const dy = clickY - ball.y;

          if (Math.hypot(dx, dy) > ball.r) {
            return;
          }

          if (state.mode !== "active") {
            state.mode = "active";
            state.settleTime = 0;
            hintEl.classList.add("hidden");
          }

          applyKick(clickX, clickY, event.pressure);
        };

        const handleGroundImpact = () => {
          if (state.mode === "active") {
            state.mode = "settling";
            state.score = 0;
            syncHud();
            hintEl.classList.remove("hidden");
            vibrate(18);
          }
        };

        const update = (time) => {
          const delta = Math.min(0.032, (time - lastTime) / 1000);
          lastTime = time;

          if (state.mode !== "idle") {
            ball.vy += settings.gravity * delta;
            ball.x += ball.vx * delta;
            ball.y += ball.vy * delta;
            ball.spin += (ball.vx / ball.r) * delta;

            if (ball.x - ball.r <= 0) {
              ball.x = ball.r;
              ball.vx = Math.abs(ball.vx) * settings.wallBounce;
            }

            if (ball.x + ball.r >= width) {
              ball.x = width - ball.r;
              ball.vx = -Math.abs(ball.vx) * settings.wallBounce;
            }

            if (ball.y + ball.r >= groundY) {
              ball.y = groundY - ball.r;

              if (ball.vy > 0) {
                ball.vy = -ball.vy * settings.groundBounce;
                ball.vx *= settings.groundFriction;
                handleGroundImpact();
              }

              if (Math.abs(ball.vy) < 40) {
                ball.vy = 0;
              }

              const rollDrag = Math.max(0, 1 - settings.rollFriction * delta);
              ball.vx *= rollDrag;

              if (state.mode === "settling") {
                if (Math.abs(ball.vx) < 6 && ball.vy === 0) {
                  state.settleTime += delta;
                } else {
                  state.settleTime = 0;
                }

                if (state.settleTime > 0.7) {
                  resetGame();
                }
              }
            }
          }

          render();
          requestAnimationFrame(update);
        };

        window.addEventListener("resize", () => {
          resize();
          render();
        });

        canvas.addEventListener("pointerdown", handlePointer);

        loadHighScore();
        resize();
        render();
        requestAnimationFrame(update);
      })();
    </script>
  </body>
</html>
