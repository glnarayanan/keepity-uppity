<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Keepy Uppy</title>
    <style>
      :root {
        --bg: #ffffff;
        --ink: #111111;
        --line: #dedede;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        overflow: hidden;
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        cursor: pointer;
        touch-action: none;
      }

      #hud {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 24px;
        font-size: 16px;
        font-weight: 600;
      }

      #hud span {
        font-weight: 700;
      }

      #hint {
        position: fixed;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 14px;
        color: #555555;
      }

      #hint.hidden {
        opacity: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="game" aria-label="Soccer juggling game"></canvas>
    <div id="hud">
      <div>Score <span id="score">0</span></div>
      <div>Best <span id="best">0</span></div>
    </div>
    <div id="hint">Click the ball to start</div>

    <script>
      (() => {
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const bestEl = document.getElementById("best");
        const hintEl = document.getElementById("hint");

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const state = {
          active: false,
          score: 0,
          best: 0,
        };

        const settings = {
          gravity: 1700,
          kick: 820,
          sideKick: 520,
          wallBounce: 0.65,
        };

        const ball = {
          x: 0,
          y: 0,
          vx: 0,
          vy: 0,
          r: 24,
        };

        let width = 0;
        let height = 0;
        let groundY = 0;
        let lastTime = performance.now();

        const highScoreKey = "keepyUppyHighScore";

        const loadHighScore = () => {
          try {
            const stored = Number.parseInt(localStorage.getItem(highScoreKey) || "0", 10);
            state.best = Number.isNaN(stored) ? 0 : stored;
          } catch (error) {
            state.best = 0;
          }
          bestEl.textContent = String(state.best);
        };

        const saveHighScore = () => {
          try {
            localStorage.setItem(highScoreKey, String(state.best));
          } catch (error) {
            // Ignore storage failures (private mode / file restrictions).
          }
        };

        const syncHud = () => {
          scoreEl.textContent = String(state.score);
          bestEl.textContent = String(state.best);
        };

        const resetBall = () => {
          ball.x = width * 0.5;
          ball.y = groundY - ball.r;
          ball.vx = 0;
          ball.vy = 0;
        };

        const resetGame = () => {
          state.active = false;
          state.score = 0;
          hintEl.classList.remove("hidden");
          resetBall();
          syncHud();
        };

        const resize = () => {
          const dpr = window.devicePixelRatio || 1;
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width * dpr;
          canvas.height = height * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ball.r = Math.max(20, Math.min(width, height) * 0.045);
          groundY = height - Math.max(40, height * 0.08);
          resetBall();
        };

        const drawBall = () => {
          ctx.save();
          ctx.translate(ball.x, ball.y);

          ctx.beginPath();
          ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
          ctx.fillStyle = "#ffffff";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#111111";
          ctx.stroke();

          ctx.fillStyle = "#111111";
          const patch = ball.r * 0.18;
          for (let i = 0; i < 5; i += 1) {
            const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
            const px = Math.cos(angle) * ball.r * 0.5;
            const py = Math.sin(angle) * ball.r * 0.5;
            ctx.beginPath();
            ctx.arc(px, py, patch, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        };

        const drawGround = () => {
          ctx.save();
          ctx.strokeStyle = "#dedede";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, groundY + 1);
          ctx.lineTo(width, groundY + 1);
          ctx.stroke();
          ctx.restore();
        };

        const render = () => {
          ctx.clearRect(0, 0, width, height);
          drawGround();
          drawBall();
        };

        const applyKick = (clickX) => {
          const normalized = clamp((clickX - ball.x) / ball.r, -1, 1);
          ball.vx += -normalized * settings.sideKick;
          ball.vy = -settings.kick;
          state.score += 1;
          if (state.score > state.best) {
            state.best = state.score;
            saveHighScore();
          }
          syncHud();
        };

        const handlePointer = (event) => {
          const rect = canvas.getBoundingClientRect();
          const clickX = event.clientX - rect.left;
          const clickY = event.clientY - rect.top;
          const dx = clickX - ball.x;
          const dy = clickY - ball.y;

          if (Math.hypot(dx, dy) > ball.r) {
            return;
          }

          if (!state.active) {
            state.active = true;
            hintEl.classList.add("hidden");
          }

          applyKick(clickX);
        };

        const update = (time) => {
          const delta = Math.min(0.032, (time - lastTime) / 1000);
          lastTime = time;

          if (state.active) {
            ball.vy += settings.gravity * delta;
            ball.x += ball.vx * delta;
            ball.y += ball.vy * delta;

            if (ball.x - ball.r <= 0) {
              ball.x = ball.r;
              ball.vx = Math.abs(ball.vx) * settings.wallBounce;
            }

            if (ball.x + ball.r >= width) {
              ball.x = width - ball.r;
              ball.vx = -Math.abs(ball.vx) * settings.wallBounce;
            }

            if (ball.y + ball.r >= groundY) {
              resetGame();
            }
          }

          render();
          requestAnimationFrame(update);
        };

        window.addEventListener("resize", () => {
          resize();
          render();
        });

        canvas.addEventListener("pointerdown", handlePointer);

        loadHighScore();
        resize();
        render();
        requestAnimationFrame(update);
      })();
    </script>
  </body>
</html>
